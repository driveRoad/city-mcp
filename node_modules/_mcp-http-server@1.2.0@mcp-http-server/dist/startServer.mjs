/**
* Copyright (c) 2025 Bytedance, Inc. and its affiliates.
* SPDX-License-Identifier: Apache-2.0
*/
import * as __WEBPACK_EXTERNAL_MODULE_express__ from "express";
import * as __WEBPACK_EXTERNAL_MODULE_node_crypto_9ba42079__ from "node:crypto";
import * as __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_types_js_fc45a208__ from "@modelcontextprotocol/sdk/types.js";
import * as __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_server_sse_js_c2d541de__ from "@modelcontextprotocol/sdk/server/sse.js";
import * as __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_server_streamableHttp_js_bc86f62b__ from "@modelcontextprotocol/sdk/server/streamableHttp.js";
async function startSseAndStreamableHttpMcpServer(params) {
    const { port, host, createMcpServer, stateless = true } = params;
    const transports = {
        streamable: new Map(),
        sse: new Map()
    };
    const app = (0, __WEBPACK_EXTERNAL_MODULE_express__["default"])();
    app.use(__WEBPACK_EXTERNAL_MODULE_express__["default"].json());
    app.use((err, _req, res, next)=>{
        if (err instanceof SyntaxError && (null == err ? void 0 : err.status) === 400 && 'body' in err) {
            res.status(400).send({
                jsonrpc: '2.0',
                error: {
                    code: __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_types_js_fc45a208__.ErrorCode.ParseError,
                    message: err.message
                }
            });
            return;
        }
        next();
    });
    app.get('/sse', async (req, res)=>{
        const mcpServer = await createMcpServer({
            headers: req.headers
        });
        console.info(`New SSE connection from ${req.ip}`);
        const sseTransport = new __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_server_sse_js_c2d541de__.SSEServerTransport('/message', res);
        transports.sse.set(sseTransport.sessionId, sseTransport);
        res.on('close', ()=>{
            transports.sse.delete(sseTransport.sessionId);
        });
        await mcpServer.connect(sseTransport);
    });
    app.post('/message', async (req, res)=>{
        const sessionId = req.query.sessionId;
        if (!sessionId) {
            res.status(400).send('Missing sessionId parameter');
            return;
        }
        const transport = transports.sse.get(sessionId);
        if (transport) await transport.handlePostMessage(req, res, req.body);
        else res.status(400).send('No transport found for sessionId');
    });
    app.post('/mcp', async (req, res)=>{
        const mcpServer = await createMcpServer({
            headers: req.headers
        });
        const sessionId = req.headers['mcp-session-id'];
        let transport;
        if (stateless) transport = new __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_server_streamableHttp_js_bc86f62b__.StreamableHTTPServerTransport({
            sessionIdGenerator: void 0
        });
        else if (sessionId && transports.streamable.has(sessionId)) transport = transports.streamable.get(sessionId);
        else if (!sessionId && (0, __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_types_js_fc45a208__.isInitializeRequest)(req.body)) {
            transport = new __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_server_streamableHttp_js_bc86f62b__.StreamableHTTPServerTransport({
                sessionIdGenerator: ()=>(0, __WEBPACK_EXTERNAL_MODULE_node_crypto_9ba42079__.randomUUID)(),
                onsessioninitialized: (sessionId)=>{
                    transports.streamable.set(sessionId, transport);
                }
            });
            transport.onclose = ()=>{
                if (null == transport ? void 0 : transport.sessionId) transports.streamable.delete(transport.sessionId);
            };
        } else {
            res.status(400).json({
                jsonrpc: '2.0',
                error: {
                    code: __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_types_js_fc45a208__.ErrorCode.ConnectionClosed,
                    message: 'Bad Request: No valid session ID provided'
                },
                id: null
            });
            return;
        }
        await mcpServer.connect(transport);
        console.log('Received MCP request:', req.body);
        try {
            await transport.handleRequest(req, res, req.body);
        } catch (error) {
            console.error('Error handling MCP request:', error);
            if (!res.headersSent) res.status(500).json({
                jsonrpc: '2.0',
                error: {
                    code: __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_types_js_fc45a208__.ErrorCode.InternalError,
                    message: 'Internal server error'
                },
                id: null
            });
        }
    });
    app.get('/mcp', async (req, res)=>{
        console.log('Received GET MCP request');
        res.writeHead(405).end(JSON.stringify({
            jsonrpc: '2.0',
            error: {
                code: __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_types_js_fc45a208__.ErrorCode.ConnectionClosed,
                message: 'Method not allowed.'
            },
            id: null
        }));
    });
    app.delete('/mcp', async (req, res)=>{
        console.log('Received DELETE MCP request');
        res.writeHead(405).end(JSON.stringify({
            jsonrpc: '2.0',
            error: {
                code: __WEBPACK_EXTERNAL_MODULE__modelcontextprotocol_sdk_types_js_fc45a208__.ErrorCode.ConnectionClosed,
                message: 'Method not allowed.'
            },
            id: null
        }));
    });
    const HOST = host || '::';
    const PORT = Number(port || process.env.PORT || 8080);
    return new Promise((resolve, reject)=>{
        const appServer = app.listen(PORT, HOST, (error)=>{
            if (error) {
                console.error('Failed to start server:', error);
                reject(error);
                return;
            }
            const address = appServer.address();
            const actualHost = ((null == address ? void 0 : address.family) === 'IPv6' ? `[${address.address}]` : null == address ? void 0 : address.address) || HOST;
            const endpoint = {
                url: `http://${actualHost}:${PORT}/mcp`,
                port: PORT,
                close: ()=>appServer.close()
            };
            console.log(`Streamable HTTP MCP Server listening at ${endpoint.url}`);
            console.log(`SSE MCP Server listening at http://${actualHost}:${PORT}/sse`);
            resolve(endpoint);
        });
        appServer.on('error', (error)=>{
            console.error('Server error:', error);
            reject(error);
        });
    });
}
export { startSseAndStreamableHttpMcpServer };
